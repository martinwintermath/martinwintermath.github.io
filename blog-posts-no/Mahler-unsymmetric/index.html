<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.45">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-06-21">

<title>The non-symmetric Mahler conjecture and self-polar polytopes – Martin Winter</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Martin Winter</span>
    </a>
  </div>
          <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../talks.html"> 
<span class="menu-text">Talks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The non-symmetric Mahler conjecture and self-polar polytopes</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 21, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>The <strong>Mahler conjecture</strong> is usually stated for centrally symmetric convex bodies. However, its non-symmetric version seems equally interesting and seemingly intractable. As it turns out, this version has a neat formulation in terms of the volume (<em>not</em> Mahler volume) of self-polar bodies. <span class="math inline">\(\DeclareMathOperator{\vol}{vol}\)</span></p>
<hr class="extend">
<p>Given a centrally symmetric convex body <span class="math inline">\(B\subset\Bbb R^d\)</span>, Kurt Mahler defined the following linearly invariant “notion of volume”, now known as the <a href="https://en.wikipedia.org/wiki/Mahler_volume"><strong>Mahler volume</strong></a>:</p>
<p><span class="math display">\[
M(B):=\operatorname{vol}(B)\cdot\operatorname{vol}(B^\circ).
\]</span></p>
<p>Here <span class="math inline">\(B^\circ:=\{y\in\Bbb R^d\mid \langle x,y\rangle\le 1\text{ for all }x\in B\}\)</span> denotes the <em>polar dual</em> of <span class="math inline">\(B\)</span>. It has long been known that the Mahler volume is maximized for the sphere (this is known as the <em>Blaschke-Santaló inequality</em>). In contrast, the minimizers seem elusive. It has equally long been conjectured that the cube has the minimal Mahler volume: for every centrally symmetric convex body <span class="math inline">\(B\subset\Bbb R^d\)</span> holds</p>
<p><span class="math display">\[M(B)\ge M(\text{$d$-cube}) = \frac{4^d}{d!}.\]</span></p>
<p>This is known as the <strong>Mahler conjecture</strong>, which, as of today, remains open. In his <a href="https://terrytao.wordpress.com/2007/03/08/open-problem-the-mahler-conjecture-on-convex-bodies/">blog post</a> Terrence Tao makes a suggestion for why the conjecture might be so hard:</p>
<blockquote class="blockquote">
<p>In my opinion, the main reason why this conjecture is so difficult is that unlike the upper bound, in which there is essentially only one extremiser up to affine transformations (namely the ball), there are many distinct extremisers for the lower bound – not only the cube and the octahedron, but also products of cubes and octahedra, polar bodies of products of cubes and octahedra, products of polar bodies of … well, you get the idea. It is really difficult to conceive of any sort of flow or optimisation procedure which would converge to exactly these bodies and no others […]</p>
</blockquote>
<p>(this family of conjectured extremizers he refers to is known as the <a href="https://en.wikipedia.org/wiki/Hanner_polytope">Hanner polytopes</a>)</p>
<p>There is however an easy way to see that the multitude of minimizers cannot be the true or only reason here: by dropping the assumption of central symmetry we obtain the <strong>non-symmetric Mahler conjecture</strong>. It asserts that the <em>simplex</em> minimizes the Mahler volume among <em>all</em> convex bodies:</p>
<p><span class="math display">\[M(B)\ge M(\text{$d$-simplex}) = \frac{(d+1)^{d+1}}{(d!)^2}.\]</span></p>
<p>This conjecture has turned out equally intractable. Yet, since we expect the simplex to be the <em>unique</em> minimizer, Terry’s explanation cannot apply.</p>
<p>We briefly addres an important technicality with the non-symmetric version: computing the Mahler volume requires computing the polar body, which is not a translation invariant construction. If <span class="math inline">\(B\)</span> is centrally symmetric, there is a preferred choice of origin (the symmetry center). For a general body there is no such preferred choice and computing the Mahler volume requires fixing the bodies location relative to the origin. However, there exists a unique point <span class="math inline">\(x\in P\)</span> (the <em>Sataló point</em>) that, if chosen as the origin, minimizes the Mahler volume.</p>
<section id="a-formulation-in-terms-of-self-polar-bodies" class="level3">
<h3 class="anchored" data-anchor-id="a-formulation-in-terms-of-self-polar-bodies">A formulation in terms of self-polar bodies</h3>
<p>The goal here is to reformulate the non-symmetric Mahler conjecture in terms of volumes of self-polar bodies, thereby avoiding volume products entirely.</p>
<!-- > **Conjecture.** The simplex has the smallest volume among all self-polar polytopes.-->
<p>A convex body <span class="math inline">\(B\)</span> is <strong>self-polar</strong> if <span class="math inline">\(B\)</span> and <span class="math inline">\(B^\circ\)</span> are isometric (or equivalently, related by an orthogonal transformation). An example is the unit ball; not however a ball of any other radius: if <span class="math inline">\(B\)</span> is a ball of radius <span class="math inline">\(r\)</span> then <span class="math inline">\(B^\circ\)</span> has radius <span class="math inline">\(1/r\)</span>, which is non-isometric to <span class="math inline">\(B\)</span>. We see that self-polarity cares about scale. Another example is a simplex, if chosen of a suitable shape and scale. In this case <span class="math inline">\(B=-B^\circ\)</span>.</p>
<p>The following conjecture is equivalent to the non-symmetric Mahler conjecture:</p>
<div class="math conj">
<p><strong>Conjecture.</strong> <br> <em>The simplex has the smallest volume among all self-polar bodies.</em></p>
</div>
<p>One direction of the equivalence is straight-forward: if <span class="math inline">\(B\)</span> is self-polar, then</p>
<p><span class="math display">\[\llap{(*)\qquad}M(B)=\vol(B)\cdot\vol(B^\circ)=\vol(B)^2.\]</span></p>
<p>Hence, if simplices minimizes <span class="math inline">\(M(\,\cdot\,)\)</span>, then since they are also self-polar, <span class="math inline">\((*)\)</span> simplices also minimize <span class="math inline">\(\vol(\,\cdot\,)\)</span> among all self-polar bodies.</p>
<p>For the other direction we need to recall the <strong>join operation</strong> <span class="math inline">\(B_1\star B_2\)</span>, and the following properties:</p>
<ul>
<li><p>if <span class="math inline">\(B_1,B_2\)</span> are of dimension <span class="math inline">\(d_1,d_2\)</span> respectively, then <span class="math inline">\(B_1\star B_2\)</span> is of dimension <span class="math inline">\(d_1+d_2+1\)</span>.</p></li>
<li><p>we can explicitle compute the volume of joins: <span class="math display">\[\vol(B_1\star B_2) = c(d_1,d_2)\cdot \vol(B_1)\cdot\vol(B_2),\]</span>where <span class="math inline">\(c(d_1,d_2)\)</span> depends on the dimensions of the bodies, but not on the bodies themselves.</p></li>
<li><p>joins commute with the polar dual operation: <span class="math inline">\((B_1\star B_2)^\circ = B_1^\circ\star B_2^\circ\)</span>. In particular, <span class="math inline">\(B\star B^\circ\)</span> is always a self-polar body!</p></li>
<li><p>joins of simplices yield simplices: <span class="math inline">\(\Delta_{d_1}\star\Delta_{d_2} = \Delta_{d_1+d_2+1}\)</span>. Moreover, if we start from simplices in their self-polar realization of minimal volume, the join is also a self-polar simplex in self-polar realization of minimal volume.</p></li>
</ul>
<p>Formulating these properties precisely requires some more care and a carefully chosen geometric realization of the join. See my previous <a href="blog-posts/join/join.qmd">blog entry</a> on the join for the details.</p>
<p>Suppose then that <span class="math inline">\(P\)</span> is a counterexample to the non-symmetric Mahler conjecture, that is, <span class="math inline">\(M(P)&lt;M(\Delta_d)\)</span>. Then <span class="math inline">\(P\star P^\circ\)</span> is a self-polar polytope with</p>
<p><span class="math display">\[
\begin{align}
\vol(P\star P^\circ) &amp;= c\cdot \vol(P)\cdot \vol(P^\circ)
\\ &amp;= c\cdot M(P)
\\ &amp;&lt; c \cdot M(\Delta_d)
\\ &amp;= c \cdot \vol(\Delta_d)\cdot\vol(\Delta_d^\circ)
\\ &amp;= c \cdot \vol(\Delta_d)\cdot\vol(\Delta_d)
\\ &amp;= \vol(\Delta_d\star\Delta_d)
= \vol(\Delta_{2d+1}).
\end{align}
\]</span></p>
<p>that is, a counterexample to Conjecture A. Conversely, Conjecture A implies the non-symmetric Mahler conjecture.</p>
<p>Conversely, suppose that <span class="math inline">\(P\)</span> is a self-polar polytope with <span class="math inline">\(\vol(P)&lt;\vol(\Delta_d)\)</span>. Then</p>
<p><span class="math display">\[M(B)=\vol(B)\cdot\vol(B^\circ)=\vol(B)^2 \ge \vol(\Delta_d)^2=\vol(\Delta_d)\cdot\vol(\Delta_d^\circ) = M(\Delta_d),\]</span></p>
<p>which is a counterexample to the non-symmetric Mahler conjecture.</p>
<p>Self-polar polytopes are not very well understood. For example, it is unknown whether every self-dual polytope has a self-polar realization.</p>
<p>Finally, I am not aware of an analogous formulation for the symmetric Mahler conjecture. Of course, one could ask for the smallest volume of a convex body of the form <span class="math inline">\(B*B^\circ\)</span>, whether <span class="math inline">\(B\)</span> is centrally symmetric. This however feels not like a significant reformulation and does not have the charme of a natural problem on its own.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>