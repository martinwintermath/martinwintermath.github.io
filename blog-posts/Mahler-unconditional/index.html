<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.45">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-08-08">

<title>The Mahler conjecture for coordinate symmetric bodies – Martin Winter</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Martin Winter</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../talks.html"> 
<span class="menu-text">Talks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">The Mahler conjecture for coordinate symmetric bodies</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 8, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="abstract">
<p>The <strong>Mahler conjecture</strong> asserts that among all centrally symmetric convex bodies <span class="math inline">\(B\)</span> the cube minimizes the volume product <span class="math inline">\(\operatorname{vol}(B)\operatorname{vol}(B^\circ)\)</span>. While famously open, several proofs have been discovered for the special case of <strong>coordinate symmetric bodies</strong>. I want to share here a surprisingly short and elegant proof by Mathieu Meyer that seems otherwise unavailable in the English litrature. <span class="math inline">\(\DeclareMathOperator{\vol}{vol}\)</span></p>
</div>
<!--### Mahler volume and Mahler conjecture ###-->
<p>Let <span class="math inline">\(B\subset\Bbb R^n\)</span> be a centrally symmetric convex body, where we shall assume <span class="math inline">\(-B=B\)</span>. Kurt Mahler defined the following linearly invariant notion of volume now known as <strong>Mahler volume</strong>:</p>
<p><span class="math display">\[
M(B):=\operatorname{vol}(B)\operatorname{vol}(B^\circ).
\]</span></p>
<p>Here <span class="math inline">\(B^\circ:=\{y\in\Bbb R^n\mid \langle x,y\rangle\le 1\text{ for all }x\in B\}\)</span> denotes the polar dual of <span class="math inline">\(B\)</span>. It has long been known that the Mahler volume attains a maximum for the sphere. There are also clear ideas for what should minimize the Mahler volume: the cube, and more generally, each of the <a href="https://en.wikipedia.org/wiki/Hanner_polytope">Hanner polytopes</a>. But a proof remains elusive. This is the infamous <em>Mahler conjecture</em>, which remains open to this day:</p>
<div class="math conj">
<p><strong>Mahler conjecture.</strong> <br> <em>For each centrally symmetric convex body <span class="math inline">\(B\subset\Bbb R^n\)</span> holds</em> <span class="math display">\[M(B)\ge M(\text{$n$-cube}) = \smash{\frac{4^n}{n!}}.\]</span></p>
</div>
<p>Below I share a very elegant and somewhat mysterious proof for the special case of <em>coordinate symmetric bodies</em> that, I believe, is not available in the English literature elsewhere. For some general background on the Mahler conjecture as well as its status, check out the <a href="https://en.wikipedia.org/wiki/Mahler_volume">Wikipedia article</a> and <a href="https://terrytao.wordpress.com/2007/03/08/open-problem-the-mahler-conjecture-on-convex-bodies/">Terry Tao’s blog entry</a> on the topic.</p>
<section id="coordinate-symmetric-bodies-and-convex-corners" class="level4">
<h4 class="anchored" data-anchor-id="coordinate-symmetric-bodies-and-convex-corners">Coordinate symmetric bodies and convex corners</h4>
<p>A convex body <span class="math inline">\(B\subset\Bbb R^n\)</span> is <strong>coordinate symmetric</strong> if it is invariant under reflection on each coordinate hyperplane <span class="math inline">\(H_i:=\{x_i=0\}\)</span>. A number of properties make coordinate symmetric bodies a natural special case for studying the Mahler conjecture: they are centrally symmetric, closed under polarity, and they contain all Hanner polytopes. <!-- $x=(x_1,...,x_n)\in B$ follows $(\pm x_1,...,\pm x_n)\in B$ as well. Or eq--> <!--This class of convex bodies is in the literature better known as *unconditional bodies*.
I am unsure about the origin of this term, and I tend to dislike it since it is seems the opposite of self-explanatory.--></p>
<p><img class="center" src="symmetric.svg" width="50%"></p>
<p>In the literature these bodies are often called “unconditional bodies”, a term going back to “unconditional convergence” motivated from Banach space theory. For geometric (that is, finite-dimensional) discussions I prefer to go with the more visually inspired term “coordinate symmetric”.</p>
<p>A coordinate symmetric body <span class="math inline">\(B\)</span> is clearly determined by its restriction <span class="math inline">\(B_+:=B\cap\Bbb R^n_+\)</span> to the positive orthant <span class="math inline">\(\Bbb R_+^n:=\{x_i\ge 0\}\)</span>. A set <span class="math inline">\(B_+\subset\Bbb R^n_+\)</span> that can be written as such a restriction of a coordinate symmetric body is called a <strong>convex corner</strong> (also known as an <em>anti-blocking body</em>).</p>
<p><img class="center" src="corners.svg" width="95%" style="margin-top:1ex; margin-bottom:1ex;"></p>
<p>Convex corners are in one-to-one correspondence with coordinate symmetric bodies. We prove the Mahler conjecture for coordinate symmetric bodies by formulating and proving a version on convex corners. For this we require a notion of polar duality that works for convex corners. If <span class="math inline">\(B_+:= B\cap\Bbb R^n_+\)</span> then</p>
<p><span class="math display">\[B_+^* := \{x\in\Bbb R^n_+\mid \langle x,y\rangle\le 1 \text{ for all } y\in B_+\} = B^\circ\cap\Bbb R^n_+.\]</span></p>
<p>Since a coordinate symmetric body consists of <span class="math inline">\(2^n\)</span> identical copies of its convex corner and hence <span class="math inline">\(\vol(B)=2^n\vol(B_+)\)</span>, it is sufficient to prove the following:</p>
<div class="math thm">
<p><strong>Theorem.</strong> <br> <em>For each convex corner <span class="math inline">\(B_+\subset\Bbb R^n_+\)</span> holds</em> <span class="math display">\[M_+(B_+):=\operatorname{vol}(B_+)\operatorname{vol}(B_+^*) \ge \smash{\frac1{n!}}.\]</span></p>
</div>
</section>
<section id="proving-the-mahler-conjecture-for-convex-corners" class="level4">
<h4 class="anchored" data-anchor-id="proving-the-mahler-conjecture-for-convex-corners">Proving the Mahler conjecture for convex corners</h4>
<p>The following very short and elegant proof is due to Mathieu Meyer from his 1986 article <em>Une caractérisation volumique de certains espaces normés</em>. It was brought to my attention by Raman Sanyal, whose presentation of the proof I follow below.</p>
<p>Let <span class="math inline">\(B_i:=B_+\cap\{x_i=0\}\)</span> and <span class="math inline">\(B_i^*:=B_+^*\cap \{x_i=0\}\)</span>, and observe that those are themselves convex corners of dimension <span class="math inline">\(n-1\)</span>. Define vectors <span class="math inline">\(v,v^*\in\Bbb R^n\)</span> with components</p>
<p><span class="math display">\[v_i := \frac{\operatorname{vol}_{n-1}(B_i)}{n \operatorname{vol}_{n}(B_+)},\quad\; v_i^* := \frac{\operatorname{vol}_{n-1}(B_i^*)}{n \operatorname{vol}_{n}(B_+^*)}\]</span></p>
<p>(where from now on we put dimension subscripts on the volumes to avoid confusion). For a point <span class="math inline">\(x\in \Bbb R_+^n\)</span> the inner product <span class="math inline">\(\langle x,v\rangle\)</span> evaluates to</p>
<p><span class="math display">\[
\langle x,v\rangle
= \sum_{i=1}^n x_i\frac{\operatorname{vol}_{n-1}(B_i)}{n \operatorname{vol}_n(B_+)}
= \frac1{\operatorname{vol}_{n}(B_+)} \cdot \sum_{i=1}^n \underbrace{\tfrac1n{x_i \operatorname{vol}_{n-1}(B_i)}}_{\operatorname{vol}_n(C_i)},
\]</span></p>
<p>where <span class="math inline">\(C_i\)</span> is the cone with base face <span class="math inline">\(B_i\)</span> and apex at <span class="math inline">\(x\)</span>.</p>
<p><img class="center" src="proof.svg" width="23%"></p>
<p>If <span class="math inline">\(x\in B_+\)</span> then the cones <span class="math inline">\(C_i\)</span> have disjoint interiors and are contained in <span class="math inline">\(B_+\)</span>. In particular, the sum of their volumes is bounded by <span class="math inline">\(\operatorname{vol}_n(B_+)\)</span>. Therefore <span class="math inline">\(\langle x,v\rangle \le 1\)</span> for all <span class="math inline">\(x\in B_+\)</span>, and hence <span class="math inline">\(v\in B_+^*\)</span>. By an analogous argument holds <span class="math inline">\(v^*\in B_+\)</span>. Hence, we can conclude</p>
<p><span class="math display">\[
\begin{align}
1\,\ge\, &amp;\langle v,v^*\rangle
=  \sum_{i=1}^n \frac{\operatorname{vol}_{n-1}(B_i)\operatorname{vol}_{n-1}(B_i^*)}{n^2\operatorname{vol}_n(B_+)\operatorname{vol}_n(B_+^*)}
= \sum_{i=1}^n \frac{M_+(B_i)}{n^2M_+(B_+)}.
\end{align}
\]</span></p>
<p>By rearranging and applying the induction hypothesis <span class="math inline">\(M_+(B_i)\ge 1/(n-1)!\)</span> we obtain</p>
<p><span class="math display">\[
M_+(B_+) \ge \frac1{n^2} \sum_{i=1}^n M_+(B_i) \ge \frac1{n^2} \cdot\frac{n}{(n-1)!} = \frac1{n!}.
\]</span></p>
<p>From this proof one can also extract the minimizers. Those turn out to be precisely the <em>Hanner corners</em> (that is, the positive corners of Hanner polytopes). Consequently, the minimizers among the coordinate symmetric bodies are indeed the Hanner polytopes.</p>
</section>
<section id="its-not-about-central-symmetry-anymore" class="level4">
<h4 class="anchored" data-anchor-id="its-not-about-central-symmetry-anymore">It’s not about central symmetry anymore</h4>
<p>Coordinate symmetric bodies might seem a bit … restrictive. After all, they require quite some symmetry. However, as it turns out, once the problem is solved for convex corners, there is no longer any need to piece them together into a coordinate symmetric body to satisfy the Mahler conjecture. Even wilder, we don’t even need central symmetry anymore!</p>
<p>A <strong>locally anti-blocking body</strong> is a convex body that if restricted to each orthant yields a convex corner (this is the official term, I don’t yet have a good idea for a more visually descriptive name).</p>
<p><img class="center" src="piecewise.svg" width="52%"></p>
<p>Locally anti-blocking bodies are a much richer family of bodie as compared to the highly symmetric coordinate symmetric bodies. In fact, they need not even be centrally symmetric! Still, they are closed under polar duality and share a number of nice properties with coordinate symmetric bodies.</p>
<p>The Mahler conjecture for locally anti-blocking bodies can be proven using the Cauchy-Schwarz inequality. For <span class="math inline">\(\sigma\in\{-1,+1\}^n\)</span> write <span class="math inline">\(\Bbb R^n_\sigma:=\{x\in\Bbb R^n\mid \sigma_i x_i\ge 0\}\)</span>. For a locally anti-blocking body <span class="math inline">\(B\)</span> define</p>
<p><span class="math display">\[
\begin{align}
w_\sigma&amp;:=\operatorname{vol}( B\cap \Bbb R^n_\sigma),\quad
w_\sigma^*:=\operatorname{vol}( B^\circ\cap \Bbb R^n_\sigma)
\end{align},
\]</span></p>
<p>which are precisely the volumes of its <span class="math inline">\(2^n\)</span> convex corners. Using the Cauchy-Schwarz inequality (CS) and the proof for convex corners <span class="math inline">\((*)\)</span>, we conclude</p>
<p><span class="math display">\[
\begin{align}
M(B)
= \operatorname{vol}(B)\operatorname{vol}(B^\circ)
&amp;=\Big(\sum_\sigma w_\sigma\Big)\Big(\sum_\sigma w_\sigma^*\Big)
\\&amp;\!\overset{\text{(CS)}}\ge \Big(\sum_\sigma \sqrt{w_\sigma w_\sigma^*}\Big)^2
\overset{(*)}\ge \Big(\frac{2^n}{\sqrt{n!}}\Big)^2 = \frac{4^n}{n!}.
\end{align}
\]</span></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="MathWinter/blogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>